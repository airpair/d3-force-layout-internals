The [force layout](https://github.com/mbostock/d3/wiki/Force-Layout) is
one of D3's most powerful tools for computing layouts. Given a set of
nodes and links between them, it applies a physical simulation to
iteratively determine an equilibrium state of the network where all
nodes are in positions that balance the forces exerted on them by
connected nodes and the environment. Apart from providing users with a
way to draw networks in a nice way without having to compute the
positions of the nodes beforehand, it can also provide visual feedback
of the layout process by animating the positions of the nodes as the
simulation progresses.

Despite its prevalence in many applications that use D3, the force
layout is one of the least understood components of the library. Apart
from the complexity of the implementation and the concepts behind it,
one of the reasons is that an out-of-the-box application is sufficient
to achieve the desired result in many cases.

In this article, we will take a look at a few issues that may arise for
advanced users or in complex applications. The basic parameters of the
force layout are well-documented on the D3 website and will not be
covered here; rather we will have a look at some of the concepts that
are *not* explained in detail in the documentation.

## Running the simulation and the `tick` event

After calling the [`.start()`
function](https://github.com/mbostock/d3/wiki/Force-Layout#start) on the
force layout, it runs asynchronously, i.e. in parallel to any other
processing in the background. At each step of the simulation, it updates
(among other things) the `x` and `y` coordinates for each of the nodes
given to the force layout. It modifies the data that represent those
nodes directly.

The `tick` event allows to synchronise the internal state of the
simulation with the display. It is generated by the simulation running
in the background or explicitly by calling the layout's [`.tick()`
function](https://github.com/mbostock/d3/wiki/Force-Layout#tick).
Usually, the handler function for this event redraws the nodes and links
to reflect their changed positions. The function is called every few
milliseconds, creating the impression of a fluid movement of the nodes
and links.

This handler function is defined by the user and may run arbitrary code.
In particular, if no handler function is attached or the attached
function does not redraw the nodes and links, the display will not
reflect the internal state of the simulation.

There are a few ways in which the functionality of the force layout can
be extended or modified through the handler function for the `tick`
event. One example of this is to modify the positions of the nodes
instead of simply updating the display to reflect what the simulation
has done. This can be used to force the nodes to be contained [within a
bounding box](http://bl.ocks.org/mbostock/1129492) or [a
circle](http://bl.ocks.org/nsonnad/5993342). 
In both of these examples, the handler function checks whether the computed coordinates are within
the allowed range and if not, resets them:

    node.attr("cx", function(d) { return d.x = Math.max(radius, Math.min(width - radius, d.x)); })
        .attr("cy", function(d) { return d.y = Math.max(radius, Math.min(height - radius, d.y)); });

Another useful modification is to redraw the display not on every tick
of the simulation, but only every few ticks or even only once at the end
of the simulation. This will speed up the rendering process with large
numbers of nodes and links or create the impression of [a static
layout](http://bl.ocks.org/mbostock/1667139) instead of a dynamically
created one. In the extreme case where only the end result is displayed,
no `tick` event handler is required &mdash; we simply run the layout for
a number of steps and then draw:

    force.start();
    for (var i = n * n; i > 0; --i) force.tick();
    force.stop();

## Modifying nodes and links

For some applications, it is necessary to change the structure of the
network after the force layout has been started, for example add nodes
or remove links. This can be achieved by simply instantiating a new
force layout with the changed nodes and links, but can result in a
"jerky" transition because the state of the previous simulation is not
taken into account.

The more elegant way is to [modify the existing
layout](http://bl.ocks.org/mbostock/1095795) by changing its internal
data structures. The nodes and links that have been given to the force
layout can be modified in-place and the simulation will pick up the
changes automatically. However, it is important that any modifications
are done in-place and not by creating new arrays of nodes or links, as
these will not be noticed by the existing force layout.

    var force = d3.layout.force()
      .nodes(nodes)
      .links(links);
    // ...
    nodes.push(a, b, c);
    links.push({source: a, target: b}, {source: a, target: c}, {source: b, target: c});

After modifying the network, it is recommended to call the layout's
`.start()` function again to restart the simulation. While the
simulation will automatically update the coordinates of new nodes, it
will not restart automatically. That is, if the simulation has settled
into an equilibrium state and no further `tick` events are generated,
adding new nodes will have no effect until it is restarted.

When changing the structure of the network, keep in mind that the
display needs to be updated accordingly by adding or removing nodes or
links. In particular, handling only the update selection to change the
position of existing nodes it no longer sufficient and the enter and
exit selections have to be dealt with as well. It is also recommended to
provide a key function to `.data()` that tells D3 how to match data and
DOM nodes, as nodes and links can be added and removed in arbitrary
positions in their respective arrays and the default index-based
matching will likely produce undesirable results.

    var node = svg.selectAll(".node"),
    link = svg.selectAll(".link");
    
    link = link.data(force.links(), function(d) { return d.source.id + "-" + d.target.id; });
    link.enter().insert("line", ".node").attr("class", "link");
    link.exit().remove();

    node = node.data(force.nodes(), function(d) { return d.id;});
    node.enter().append("circle").attr("class", function(d) { return "node " + d.id; }).attr("r", 8);
    node.exit().remove();

### Specifying links using node indices

The force layout supports two ways of specifying the end points of links
&mdash; through the index of the respective node in the array of nodes,
and through a reference to the node object. Internally, the former is
replaced by the latter when the simulation is started. That is, all
indices are replaced by references to the respective objects before
starting the layout.

This has important ramifications when updating the links dynamically. If
using the index-based method of specifying the end points, `.start()`
*must* be called after adding the new links to replace the indices with
references to the actual nodes. In addition, the simulation should be
stopped before making these modifications. Otherwise, the simulation
will generate errors.

## Conclusions

This article provided a glimpse at some of the internals of D3's force
layout that may be relevant for more advanced applications. There are
many more parameters to tweak and concepts to understand, but hopefully
you have gained some useful knowledge that you can put into practice in
your next D3 project.
